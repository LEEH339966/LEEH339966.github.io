{"title":"使用阿里云搭建自己的博客","slug":"函数式接口","date":"2020-09-18T06:07:20.362Z","updated":"2020-09-18T06:06:42.222Z","comments":true,"path":"api/articles/函数式接口.json","photos":[],"link":"","excerpt":"【函数式接口】主要内容自定义函数式接口函数式编程常用函数式接口学习目标  能够使用@FunctionalInterface注解  能够自定义无参无返回函数式接口  能够自定义有参有返回函数式接口  能够理解Lambda延迟执行的特点  能够使用Lambda作为方法的参数  能够使用Lambda作为方法的返回值  能够使用Supplier函数式接口  能够使用Consumer函数式接口  能够使用Function&lt;T, R&gt;函数式接口  能够使用Predicate函数式接口","covers":["https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/60d4fea7ba041eaa32730221622c1a47.jpg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/01-Lambda.jpeg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/02-Annotation.jpeg","E:%5Cweb%25E5%25BC%2580%25E5%258F%2591%5C%25E8%25B5%2584%25E6%2596%2599%5Cday23-%25E5%2587%25BD%25E6%2595%25B0%25E5%25BC%258F%25E6%258E%25A5%25E5%258F%25A3%5C%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD-day12-%25E5%2587%25BD%25E6%2595%25B0%25E5%25BC%258F%25E6%258E%25A5%25E5%258F%25A3%5Cimg%5C01-%25E7%25BC%2596%25E7%25A8%258B.jpeg","img/02-%25E5%25BB%25B6%25E8%25BF%259F.jpeg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/03-%E5%B7%A5%E5%85%B7%E7%AE%B1.jpeg"],"content":"<hr>\n<h1 id=\"【函数式接口】\"><a href=\"#【函数式接口】\" class=\"headerlink\" title=\"【函数式接口】\"></a>【函数式接口】</h1><h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><ul>\n<li><p>自定义函数式接口</p>\n</li>\n<li><p>函数式编程</p>\n</li>\n<li><p>常用函数式接口</p>\n</li>\n</ul>\n<h2 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h2><ul>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够使用@FunctionalInterface注解</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够自定义无参无返回函数式接口</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够自定义有参有返回函数式接口</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够理解Lambda延迟执行的特点</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够使用Lambda作为方法的参数</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够使用Lambda作为方法的返回值</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够使用Supplier<T>函数式接口</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够使用Consumer<T>函数式接口</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够使用Function&lt;T, R&gt;函数式接口</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\">  能够使用Predicate<T>函数式接口</p>\n<a id=\"more\"></a>\n\n<img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/60d4fea7ba041eaa32730221622c1a47.jpg\" style=\"zoom:67%;\" />\n\n</li>\n</ul>\n<h1 id=\"第一章-函数式接口\"><a href=\"#第一章-函数式接口\" class=\"headerlink\" title=\"第一章 函数式接口\"></a>第一章 函数式接口</h1><p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/01-Lambda.jpeg\"></p>\n<h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。</p>\n<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>\n<blockquote>\n<p>备注：“<strong>语法糖</strong>”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p>\n</blockquote>\n<h2 id=\"1-2-格式\"><a href=\"#1-2-格式\" class=\"headerlink\" title=\"1.2 格式\"></a>1.2 格式</h2><p>只要确保接口中有且仅有一个抽象方法即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 <span class=\"class\"><span class=\"keyword\">interface</span> 接口名称 </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class=\"line\">    <span class=\"comment\">// 其他非抽象方法内容</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于接口当中抽象方法的<code>public abstract</code>是可以省略的，所以定义一个函数式接口很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFunctionalInterface</span> </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-FunctionalInterface注解\"><a href=\"#1-3-FunctionalInterface注解\" class=\"headerlink\" title=\"1.3 @FunctionalInterface注解\"></a>1.3 @FunctionalInterface注解</h2><p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/02-Annotation.jpeg\"></p>\n<p>与<code>@Override</code>注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFunctionalInterface</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要<strong>注意</strong>的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>\n<h2 id=\"1-4-自定义函数式接口\"><a href=\"#1-4-自定义函数式接口\" class=\"headerlink\" title=\"1.4 自定义函数式接口\"></a>1.4 自定义函数式接口</h2><p>对于刚刚定义好的<code>MyFunctionalInterface</code>函数式接口，典型使用场景就是作为方法的参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo09FunctionalInterface</span> </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"comment\">// 使用自定义的函数式接口作为方法参数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(MyFunctionalInterface inter)</span> </span>&#123;</span><br><span class=\"line\">\t\tinter.myMethod(); <span class=\"comment\">// 调用自定义的函数式接口方法</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用使用函数式接口的方法</span></span><br><span class=\"line\">\t\tdoSomething(() -&gt; System.out.println(<span class=\"string\">&quot;Lambda执行啦！&quot;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第二章-函数式编程\"><a href=\"#第二章-函数式编程\" class=\"headerlink\" title=\"第二章 函数式编程\"></a>第二章 函数式编程</h1><p><img src=\"E:%5Cweb%25E5%25BC%2580%25E5%258F%2591%5C%25E8%25B5%2584%25E6%2596%2599%5Cday23-%25E5%2587%25BD%25E6%2595%25B0%25E5%25BC%258F%25E6%258E%25A5%25E5%258F%25A3%5C%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD-day12-%25E5%2587%25BD%25E6%2595%25B0%25E5%25BC%258F%25E6%258E%25A5%25E5%258F%25A3%5Cimg%5C01-%25E7%25BC%2596%25E7%25A8%258B.jpeg\"></p>\n<p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。下面我们做一个初探。</p>\n<h2 id=\"2-1-Lambda的延迟执行\"><a href=\"#2-1-Lambda的延迟执行\" class=\"headerlink\" title=\"2.1 Lambda的延迟执行\"></a>2.1 Lambda的延迟执行</h2><p><img src=\"img/02-%25E5%25BB%25B6%25E8%25BF%259F.jpeg\"></p>\n<p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。</p>\n<h3 id=\"性能浪费的日志案例\"><a href=\"#性能浪费的日志案例\" class=\"headerlink\" title=\"性能浪费的日志案例\"></a>性能浪费的日志案例</h3><p>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 </p>\n<p>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo01Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          \tSystem.out.println(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">        String msgC = <span class=\"string\">&quot;Java&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        log(<span class=\"number\">1</span>, msgA + msgB + msgC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码存在问题：无论级别是否满足要求，作为<code>log</code>方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p>\n<blockquote>\n<p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如：<code>LOGGER.debug(&quot;变量&#123;&#125;的取值为&#123;&#125;。&quot;, &quot;os&quot;, &quot;macOS&quot;)</code>，其中的大括号<code>&#123;&#125;</code>为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p>\n</blockquote>\n<h3 id=\"体验Lambda的更优写法\"><a href=\"#体验Lambda的更优写法\" class=\"headerlink\" title=\"体验Lambda的更优写法\"></a>体验Lambda的更优写法</h3><p>使用Lambda必然需要一个函数式接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MessageBuilder</span> </span>&#123;  </span><br><span class=\"line\">   \t<span class=\"function\">String <span class=\"title\">buildMessage</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后对<code>log</code>方法进行改造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo02LoggerLambda</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> level, MessageBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          \tSystem.out.println(builder.buildMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">        String msgC = <span class=\"string\">&quot;Java&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        log(<span class=\"number\">1</span>, () -&gt; msgA + msgB + msgC );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p>\n<h3 id=\"证明Lambda的延迟\"><a href=\"#证明Lambda的延迟\" class=\"headerlink\" title=\"证明Lambda的延迟\"></a>证明Lambda的延迟</h3><p>下面的代码可以通过结果进行验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo03LoggerDelay</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> level, MessageBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          \tSystem.out.println(builder.buildMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">        String msgC = <span class=\"string\">&quot;Java&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        log(<span class=\"number\">2</span>, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Lambda执行！&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> msgA + msgB + msgC;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p>\n<blockquote>\n<p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p>\n</blockquote>\n<h2 id=\"2-2-使用Lambda作为参数和返回值\"><a href=\"#2-2-使用Lambda作为参数和返回值\" class=\"headerlink\" title=\"2.2 使用Lambda作为参数和返回值\"></a>2.2 使用Lambda作为参数和返回值</h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。</p>\n<p>例如<code>java.lang.Runnable</code>接口就是一个函数式接口，假设有一个<code>startThread</code>方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和<code>Thread</code>类的构造方法参数为<code>Runnable</code>没有本质区别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo04Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startThread</span><span class=\"params\">(Runnable task)</span> </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">new</span> Thread(task).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tstartThread(() -&gt; System.out.println(<span class=\"string\">&quot;线程任务执行！&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个<code>java.util.Comparator</code>接口类型的对象作为排序器时,就可以调该方法获取。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo06Comparator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Comparator&lt;String&gt; <span class=\"title\">newComparator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> (a, b) -&gt; b.length() - a.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = &#123; <span class=\"string\">&quot;abc&quot;</span>, <span class=\"string\">&quot;ab&quot;</span>, <span class=\"string\">&quot;abcd&quot;</span> &#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(array));</span><br><span class=\"line\">        Arrays.sort(array, newComparator());</span><br><span class=\"line\">        System.out.println(Arrays.toString(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中直接return一个Lambda表达式即可。</p>\n<h1 id=\"第三章-常用函数式接口\"><a href=\"#第三章-常用函数式接口\" class=\"headerlink\" title=\"第三章 常用函数式接口\"></a>第三章 常用函数式接口</h1><p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/03-%E5%B7%A5%E5%85%B7%E7%AE%B1.jpeg\"></p>\n<p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在<code>java.util.function</code>包中被提供。下面是最简单的几个接口及使用示例。</p>\n<h2 id=\"3-1-Supplier接口\"><a href=\"#3-1-Supplier接口\" class=\"headerlink\" title=\"3.1 Supplier接口\"></a>3.1 Supplier接口</h2><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code>。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“<strong>对外提供</strong>”一个符合泛型类型的对象数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Supplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo08Supplier</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getString</span><span class=\"params\">(Supplier&lt;String&gt; function)</span> </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> function.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">        System.out.println(getString(() -&gt; msgA + msgB));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-练习：求数组元素最大值\"><a href=\"#3-2-练习：求数组元素最大值\" class=\"headerlink\" title=\"3.2 练习：求数组元素最大值\"></a>3.2 练习：求数组元素最大值</h2><h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>使用<code>Supplier</code>接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型请使用<code>java.lang.Integer</code>类。</p>\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo02Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定一个方法,方法的参数传递Supplier,泛型使用Integer</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getMax</span><span class=\"params\">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sup.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">52</span>,<span class=\"number\">333</span>,<span class=\"number\">23</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//调用getMax方法,参数传递Lambda</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxNum = getMax(()-&gt;&#123;</span><br><span class=\"line\">           <span class=\"comment\">//计算数组的最大值</span></span><br><span class=\"line\">           <span class=\"keyword\">int</span> max = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : arr)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(i&gt;max)&#123;</span><br><span class=\"line\">                   max = i;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(maxNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-Consumer接口\"><a href=\"#3-3-Consumer接口\" class=\"headerlink\" title=\"3.3 Consumer接口\"></a>3.3 Consumer接口</h2><p><code>java.util.function.Consumer&lt;T&gt;</code>接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费</strong>一个数据，其数据类型由泛型决定。</p>\n<h3 id=\"抽象方法：accept\"><a href=\"#抽象方法：accept\" class=\"headerlink\" title=\"抽象方法：accept\"></a>抽象方法：accept</h3><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>，意为消费一个指定泛型的数据。基本使用如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo09Consumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">consumeString</span><span class=\"params\">(Consumer&lt;String&gt; function)</span> </span>&#123;</span><br><span class=\"line\">      \tfunction.accept(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        consumeString(s -&gt; System.out.println(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，更好的写法是使用方法引用。</p>\n<h3 id=\"默认方法：andThen\"><a href=\"#默认方法：andThen\" class=\"headerlink\" title=\"默认方法：andThen\"></a>默认方法：andThen</h3><p>如果一个方法的参数和返回值全都是<code>Consumer</code>类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是<code>Consumer</code>接口中的default方法<code>andThen</code>。下面是JDK的源代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> Consumer&lt;T&gt; <span class=\"title\">andThen</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> T&gt; after)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(after);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>备注：<code>java.util.Objects</code>的<code>requireNonNull</code>静态方法将会在参数为null时主动抛出<code>NullPointerException</code>异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p>\n</blockquote>\n<p>要想实现组合，需要两个或多个Lambda表达式即可，而<code>andThen</code>的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo10ConsumerAndThen</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">consumeString</span><span class=\"params\">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> </span>&#123;</span><br><span class=\"line\">      \tone.andThen(two).accept(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        consumeString(</span><br><span class=\"line\">            s -&gt; System.out.println(s.toUpperCase()),</span><br><span class=\"line\">            s -&gt; System.out.println(s.toLowerCase()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的组合。</p>\n<h2 id=\"3-4-练习：格式化打印信息\"><a href=\"#3-4-练习：格式化打印信息\" class=\"headerlink\" title=\"3.4 练习：格式化打印信息\"></a>3.4 练习：格式化打印信息</h2><h3 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>下面的字符串数组当中存有多条信息，请按照格式“<code>姓名：XX。性别：XX。</code>”的格式将信息打印出来。要求将打印姓名的动作作为第一个<code>Consumer</code>接口的Lambda实例，将打印性别的动作作为第二个<code>Consumer</code>接口的Lambda实例，将两个<code>Consumer</code>接口按照顺序“拼接”到一起。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  \tString[] array = &#123; <span class=\"string\">&quot;迪丽热巴,女&quot;</span>, <span class=\"string\">&quot;古力娜扎,女&quot;</span>, <span class=\"string\">&quot;马尔扎哈,男&quot;</span> &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = &#123; <span class=\"string\">&quot;迪丽热巴,女&quot;</span>, <span class=\"string\">&quot;古力娜扎,女&quot;</span>, <span class=\"string\">&quot;马尔扎哈,男&quot;</span> &#125;;</span><br><span class=\"line\">        printInfo(s -&gt; System.out.print(<span class=\"string\">&quot;姓名：&quot;</span> + s.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">0</span>]),</span><br><span class=\"line\">                  s -&gt; System.out.println(<span class=\"string\">&quot;。性别：&quot;</span> + s.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">1</span>] + <span class=\"string\">&quot;。&quot;</span>),</span><br><span class=\"line\">                  array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printInfo</span><span class=\"params\">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two, String[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String info : array) &#123;</span><br><span class=\"line\">            one.andThen(two).accept(info); <span class=\"comment\">// 姓名：迪丽热巴。性别：女。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-Predicate接口\"><a href=\"#3-5-Predicate接口\" class=\"headerlink\" title=\"3.5 Predicate接口\"></a>3.5 Predicate接口</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code>接口。</p>\n<h3 id=\"抽象方法：test\"><a href=\"#抽象方法：test\" class=\"headerlink\" title=\"抽象方法：test\"></a>抽象方法：test</h3><p><code>Predicate</code>接口中包含一个抽象方法：<code>boolean test(T t)</code>。用于条件判断的场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo15PredicateTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> veryLong = predicate.test(<span class=\"string\">&quot;HelloWorld&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;字符串很长吗：&quot;</span> + veryLong);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        method(s -&gt; s.length() &gt; <span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。</p>\n<h3 id=\"默认方法：and\"><a href=\"#默认方法：and\" class=\"headerlink\" title=\"默认方法：and\"></a>默认方法：and</h3><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个<code>Predicate</code>条件使用“与”逻辑连接起来实现“<strong>并且</strong>”的效果时，可以使用default方法<code>and</code>。其JDK源码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> Predicate&lt;T&gt; <span class=\"title\">and</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; other)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(other);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo16PredicateAnd</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isValid = one.and(two).test(<span class=\"string\">&quot;Helloworld&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;字符串符合要求吗：&quot;</span> + isValid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        method(s -&gt; s.contains(<span class=\"string\">&quot;H&quot;</span>), s -&gt; s.contains(<span class=\"string\">&quot;W&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认方法：or\"><a href=\"#默认方法：or\" class=\"headerlink\" title=\"默认方法：or\"></a>默认方法：or</h3><p>与<code>and</code>的“与”类似，默认方法<code>or</code>实现逻辑关系中的“<strong>或</strong>”。JDK源码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> Predicate&lt;T&gt; <span class=\"title\">or</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; other)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(other);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo16PredicateAnd</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isValid = one.or(two).test(<span class=\"string\">&quot;Helloworld&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;字符串符合要求吗：&quot;</span> + isValid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        method(s -&gt; s.contains(<span class=\"string\">&quot;H&quot;</span>), s -&gt; s.contains(<span class=\"string\">&quot;W&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认方法：negate\"><a href=\"#默认方法：negate\" class=\"headerlink\" title=\"默认方法：negate\"></a>默认方法：negate</h3><p>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法<code>negate</code>的JDK源代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> Predicate&lt;T&gt; <span class=\"title\">negate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (t) -&gt; !test(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在<code>test</code>方法调用之前调用<code>negate</code>方法，正如<code>and</code>和<code>or</code>方法一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo17PredicateNegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> veryLong = predicate.negate().test(<span class=\"string\">&quot;HelloWorld&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;字符串很长吗：&quot;</span> + veryLong);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tmethod(s -&gt; s.length() &lt; <span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-练习：集合信息筛选\"><a href=\"#3-6-练习：集合信息筛选\" class=\"headerlink\" title=\"3.6 练习：集合信息筛选\"></a>3.6 练习：集合信息筛选</h2><h3 id=\"题目-2\"><a href=\"#题目-2\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>数组当中有多条“姓名+性别”的信息如下，请通过<code>Predicate</code>接口的拼装将符合要求的字符串筛选到集合<code>ArrayList</code>中，需要同时满足两个条件：</p>\n<ol>\n<li>必须为女生；</li>\n<li>姓名为4个字。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoPredicate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tString[] array = &#123; <span class=\"string\">&quot;迪丽热巴,女&quot;</span>, <span class=\"string\">&quot;古力娜扎,女&quot;</span>, <span class=\"string\">&quot;马尔扎哈,男&quot;</span>, <span class=\"string\">&quot;赵丽颖,女&quot;</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答-2\"><a href=\"#解答-2\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoPredicate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = &#123; <span class=\"string\">&quot;迪丽热巴,女&quot;</span>, <span class=\"string\">&quot;古力娜扎,女&quot;</span>, <span class=\"string\">&quot;马尔扎哈,男&quot;</span>, <span class=\"string\">&quot;赵丽颖,女&quot;</span> &#125;;</span><br><span class=\"line\">        List&lt;String&gt; list = filter(array,</span><br><span class=\"line\">                                   s -&gt; <span class=\"string\">&quot;女&quot;</span>.equals(s.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">1</span>]),</span><br><span class=\"line\">                                   s -&gt; s.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">0</span>].length() == <span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">filter</span><span class=\"params\">(String[] array, Predicate&lt;String&gt; one, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String info : array) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (one.and(two).test(info)) &#123;</span><br><span class=\"line\">                list.add(info);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7-Function接口\"><a href=\"#3-7-Function接口\" class=\"headerlink\" title=\"3.7 Function接口\"></a>3.7 Function接口</h2><p><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>\n<h3 id=\"抽象方法：apply\"><a href=\"#抽象方法：apply\" class=\"headerlink\" title=\"抽象方法：apply\"></a>抽象方法：apply</h3><p><code>Function</code>接口中最主要的抽象方法为：<code>R apply(T t)</code>，根据类型T的参数获取类型R的结果。</p>\n<p>使用的场景例如：将<code>String</code>类型转换为<code>Integer</code>类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo11FunctionApply</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Function&lt;String, Integer&gt; function)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = function.apply(<span class=\"string\">&quot;10&quot;</span>);</span><br><span class=\"line\">        System.out.println(num + <span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        method(s -&gt; Integer.parseInt(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，最好是通过方法引用的写法。</p>\n<h3 id=\"默认方法：andThen-1\"><a href=\"#默认方法：andThen-1\" class=\"headerlink\" title=\"默认方法：andThen\"></a>默认方法：andThen</h3><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作。JDK源代码如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> &lt;V&gt; <span class=\"function\">Function&lt;T, V&gt; <span class=\"title\">andThen</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(after);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法同样用于“先做什么，再做什么”的场景，和<code>Consumer</code>中的<code>andThen</code>差不多：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo12FunctionAndThen</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = one.andThen(two).apply(<span class=\"string\">&quot;10&quot;</span>);</span><br><span class=\"line\">        System.out.println(num + <span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        method(str-&gt;Integer.parseInt(str)+<span class=\"number\">10</span>, i -&gt; i *= <span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过<code>andThen</code>按照前后顺序组合到了一起。</p>\n<blockquote>\n<p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p>\n</blockquote>\n<h2 id=\"3-8-练习：自定义函数模型拼接\"><a href=\"#3-8-练习：自定义函数模型拼接\" class=\"headerlink\" title=\"3.8 练习：自定义函数模型拼接\"></a>3.8 练习：自定义函数模型拼接</h2><h3 id=\"题目-3\"><a href=\"#题目-3\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>请使用<code>Function</code>进行函数模型的拼接，按照顺序需要执行的多个函数操作为：</p>\n<pre><code> String str = &quot;赵丽颖,20&quot;;</code></pre>\n<ol>\n<li>将字符串截取数字年龄部分，得到字符串；</li>\n<li>将上一步的字符串转换成为int类型的数字；</li>\n<li>将上一步的int数字累加100，得到结果int数字。</li>\n</ol>\n<h3 id=\"解答-3\"><a href=\"#解答-3\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoFunction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String str = <span class=\"string\">&quot;赵丽颖,20&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age = getAgeNum(str, s -&gt; s.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">1</span>],</span><br><span class=\"line\">                            s -&gt;Integer.parseInt(s),</span><br><span class=\"line\">                            n -&gt; n += <span class=\"number\">100</span>);</span><br><span class=\"line\">        System.out.println(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getAgeNum</span><span class=\"params\">(String str, Function&lt;String, String&gt; one,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 Function&lt;String, Integer&gt; two,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 Function&lt;Integer, Integer&gt; three)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> one.andThen(two).andThen(three).apply(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"hexo网站搭建","slug":"hexo网站搭建","count":6,"path":"api/categories/hexo网站搭建.json"}],"tags":[{"name":"函数式接口","slug":"函数式接口","count":1,"path":"api/tags/函数式接口.json"}]}