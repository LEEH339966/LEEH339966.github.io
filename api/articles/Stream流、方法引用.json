{"title":"Stream流、方法引用","slug":"Stream流、方法引用","date":"2020-09-17T12:45:54.088Z","updated":"2020-09-17T13:04:47.431Z","comments":true,"path":"api/articles/Stream流、方法引用.json","photos":[],"link":"","excerpt":"【Stream流、方法引用】主要内容Stream流方法引用学习目标 能够理解流与集合相比的优点 能够理解流的延迟执行特点 能够通过集合、映射或数组获取流 能够掌握常用的流操作 能够使用输出语句的方法引用3 能够通过4种方式使用方法引用 能够使用类和数组的构造器引用8","covers":["https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/6dd81def721e4125a337ca89efaa3849.jpg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/02-%E6%B5%81%E6%B0%B4%E7%BA%BF.jpeg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/01-%E6%B5%81%E5%BC%8F%E6%80%9D%E6%83%B3%E7%A4%BA%E6%84%8F%E5%9B%BE.png","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/stream%E8%AF%AD%E6%B3%95.jpg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/filter%E8%AF%AD%E6%B3%95(1).jpg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/limit%E8%AF%AD%E6%B3%95.jpg","E:%5Cweb%25E5%25BC%2580%25E5%258F%2591%5C%25E8%25B5%2584%25E6%2596%2599%5Cday24-Stream%25E6%25B5%2581%25E3%2580%2581%25E6%2596%25B9%25E6%25B3%2595%25E5%25BC%2595%25E7%2594%25A8%5C%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD-day13-Stream%25E6%25B5%2581%25E3%2580%2581%25E6%2596%25B9%25E6%25B3%2595%25E5%25BC%2595%25E7%2594%25A8%5Cimg%5Climit%25E8%25AF%25AD%25E6%25B3%2595.jpg","https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/skip%E8%AF%AD%E6%B3%95.jpg"],"content":"<hr>\n<h1 id=\"【Stream流、方法引用】\"><a href=\"#【Stream流、方法引用】\" class=\"headerlink\" title=\"【Stream流、方法引用】\"></a>【Stream流、方法引用】</h1><h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><ul>\n<li>Stream流</li>\n<li>方法引用</li>\n</ul>\n<h2 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 能够理解流与集合相比的优点</li>\n<li><input disabled=\"\" type=\"checkbox\"> 能够理解流的延迟执行特点</li>\n<li><input disabled=\"\" type=\"checkbox\"> 能够通过集合、映射或数组获取流</li>\n<li><input disabled=\"\" type=\"checkbox\"> 能够掌握常用的流操作</li>\n<li><input disabled=\"\" type=\"checkbox\"> 能够使用输出语句的方法引用3</li>\n<li><input disabled=\"\" type=\"checkbox\"> 能够通过4种方式使用方法引用</li>\n<li><input disabled=\"\" type=\"checkbox\"> 能够使用类和数组的构造器引用8</li>\n</ul>\n<a id=\"more\"></a>\n\n<h1 id=\"第一章-Stream流\"><a href=\"#第一章-Stream流\" class=\"headerlink\" title=\"第一章 Stream流\"></a>第一章 Stream流</h1><p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带来的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库既有的弊端。</p>\n<img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/6dd81def721e4125a337ca89efaa3849.jpg\" alt=\"背包包的女孩\" style=\"zoom:67%;\" />\n\n<h2 id=\"1-1-引言\"><a href=\"#1-1-引言\" class=\"headerlink\" title=\"1.1 引言\"></a>1.1 引言</h2><h3 id=\"传统集合的多步遍历代码\"><a href=\"#传统集合的多步遍历代码\" class=\"headerlink\" title=\"传统集合的多步遍历代码\"></a>传统集合的多步遍历代码</h3><p>几乎所有的集合（如<code>Collection</code>接口或<code>Map</code>接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo01ForEach</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张无忌&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;赵敏&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张强&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张三丰&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : list) &#123;</span><br><span class=\"line\">          \tSystem.out.println(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。</p>\n<h3 id=\"循环遍历的弊端\"><a href=\"#循环遍历的弊端\" class=\"headerlink\" title=\"循环遍历的弊端\"></a>循环遍历的弊端</h3><p>Java 8的Lambda让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p>\n<ul>\n<li>for循环的语法就是“<strong>怎么做</strong>”</li>\n<li>for循环的循环体才是“<strong>做什么</strong>”</li>\n</ul>\n<p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p>\n<p>试想一下，如果希望对集合中的元素进行筛选过滤：</p>\n<ol>\n<li>将集合A根据条件一过滤为<strong>子集B</strong>；</li>\n<li>然后再根据条件二过滤为<strong>子集C</strong>。</li>\n</ol>\n<p>那怎么办？在Java 8之前的做法可能为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo02NormalFilter</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张无忌&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;赵敏&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张强&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张三丰&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; zhangList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.startsWith(<span class=\"string\">&quot;张&quot;</span>)) &#123;</span><br><span class=\"line\">              \tzhangList.add(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; shortList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : zhangList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.length() == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">              \tshortList.add(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : shortList) &#123;</span><br><span class=\"line\">          \tSystem.out.println(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码中含有三个循环，每一个作用不同：</p>\n<ol>\n<li>首先筛选所有姓张的人；</li>\n<li>然后筛选名字有三个字的人；</li>\n<li>最后进行对结果进行打印输出。</li>\n</ol>\n<p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是。</strong>循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p>\n<p>那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</p>\n<h3 id=\"Stream的更优写法\"><a href=\"#Stream的更优写法\" class=\"headerlink\" title=\"Stream的更优写法\"></a>Stream的更优写法</h3><p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo03StreamFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张无忌&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;赵敏&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张强&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;张三丰&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        list.stream()</span><br><span class=\"line\">          \t.filter(s -&gt; s.startsWith(<span class=\"string\">&quot;张&quot;</span>))</span><br><span class=\"line\">            .filter(s -&gt; s.length() == <span class=\"number\">3</span>)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p>\n<h2 id=\"1-2-流式思想概述\"><a href=\"#1-2-流式思想概述\" class=\"headerlink\" title=\"1.2 流式思想概述\"></a>1.2 流式思想概述</h2><p><strong>注意：请暂时忘记对传统IO流的固有印象！</strong></p>\n<p>整体来看，流式思想类似于工厂车间的“<strong>生产流水线</strong>”。</p>\n<p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/02-%E6%B5%81%E6%B0%B4%E7%BA%BF.jpeg\"></p>\n<p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。</p>\n<p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/01-%E6%B5%81%E5%BC%8F%E6%80%9D%E6%83%B3%E7%A4%BA%E6%84%8F%E5%9B%BE.png\"></p>\n<p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。</p>\n<p>这里的<code>filter</code>、<code>map</code>、<code>skip</code>都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法<code>count</code>执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p>\n<blockquote>\n<p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p>\n</blockquote>\n<p>Stream（流）是一个来自数据源的元素队列</p>\n<ul>\n<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>\n<li><strong>数据源</strong> 流的来源。 可以是集合，数组 等。</li>\n</ul>\n<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>\n<ul>\n<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>\n<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li>\n</ul>\n<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p>\n<h2 id=\"1-3-获取流\"><a href=\"#1-3-获取流\" class=\"headerlink\" title=\"1.3 获取流\"></a>1.3 获取流</h2><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</p>\n<p>获取一个流非常简单，有以下几种常用的方式：</p>\n<ul>\n<li>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流；</li>\n<li><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流。</li>\n</ul>\n<h3 id=\"根据Collection获取流\"><a href=\"#根据Collection获取流\" class=\"headerlink\" title=\"根据Collection获取流\"></a>根据Collection获取流</h3><p>首先，<code>java.util.Collection</code>接口中加入了default方法<code>stream</code>用来获取流，所以其所有实现类均可获取流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo04GetStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        Vector&lt;String&gt; vector = <span class=\"keyword\">new</span> Vector&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"根据Map获取流\"><a href=\"#根据Map获取流\" class=\"headerlink\" title=\"根据Map获取流\"></a>根据Map获取流</h3><p><code>java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo05GetStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class=\"line\">        Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class=\"line\">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"根据数组获取流\"><a href=\"#根据数组获取流\" class=\"headerlink\" title=\"根据数组获取流\"></a>根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以<code>Stream</code>接口中提供了静态方法<code>of</code>，使用很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo06GetStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = &#123; <span class=\"string\">&quot;张无忌&quot;</span>, <span class=\"string\">&quot;张翠山&quot;</span>, <span class=\"string\">&quot;张三丰&quot;</span>, <span class=\"string\">&quot;张一元&quot;</span> &#125;;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>备注：<code>of</code>方法的参数其实是一个可变参数，所以支持数组。</p>\n</blockquote>\n<h2 id=\"1-4-常用方法\"><a href=\"#1-4-常用方法\" class=\"headerlink\" title=\"1.4 常用方法\"></a>1.4 常用方法</h2><p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/stream%E8%AF%AD%E6%B3%95.jpg\"></p>\n<p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p>\n<ul>\n<li><p><strong>延迟方法</strong>：返回值类型仍然是<code>Stream</code>接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</p>\n</li>\n<li><p><strong>终结方法</strong>：返回值类型不再是<code>Stream</code>接口自身类型的方法，因此不再支持类似<code>StringBuilder</code>那样的链式调用。本小节中，终结方法包括<code>count</code>和<code>forEach</code>方法。</p>\n</li>\n</ul>\n<blockquote>\n<p>备注：本小节之外的更多方法，请自行参考API文档。</p>\n</blockquote>\n<h3 id=\"逐一处理：forEach\"><a href=\"#逐一处理：forEach\" class=\"headerlink\" title=\"逐一处理：forEach\"></a>逐一处理：forEach</h3><p>虽然方法名字叫<code>forEach</code>，但是与for循环中的“for-each”昵称不同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>该方法接收一个<code>Consumer</code>接口函数，会将每一个流元素交给该函数进行处理。</p>\n<h4 id=\"复习Consumer接口\"><a href=\"#复习Consumer接口\" class=\"headerlink\" title=\"复习Consumer接口\"></a>复习Consumer接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class=\"line\">Consumer接口中包含抽象方法<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(T t)</span>，意为消费一个指定泛型的数据。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"基本使用：\"><a href=\"#基本使用：\" class=\"headerlink\" title=\"基本使用：\"></a>基本使用：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo12StreamForEach</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;张无忌&quot;</span>, <span class=\"string\">&quot;张三丰&quot;</span>, <span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        stream.forEach(name-&gt; System.out.println(name));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过滤：filter\"><a href=\"#过滤：filter\" class=\"headerlink\" title=\"过滤：filter\"></a>过滤：filter</h3><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。方法签名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Stream&lt;T&gt; <span class=\"title\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>该接口接收一个<code>Predicate</code>函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p>\n<p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/filter%E8%AF%AD%E6%B3%95(1).jpg\" alt=\"filter语法(1)\"></p>\n<h4 id=\"复习Predicate接口\"><a href=\"#复习Predicate接口\" class=\"headerlink\" title=\"复习Predicate接口\"></a>复习Predicate接口</h4><p>此前我们已经学习过<code>java.util.stream.Predicate</code>函数式接口，其中唯一的抽象方法为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的<code>filter</code>方法将会留用元素；如果结果为false，那么<code>filter</code>方法将会舍弃元素。</p>\n<h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><p>Stream流中的<code>filter</code>方法基本使用的代码如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo07StreamFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; original = Stream.of(<span class=\"string\">&quot;张无忌&quot;</span>, <span class=\"string\">&quot;张三丰&quot;</span>, <span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(<span class=\"string\">&quot;张&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p>\n<h3 id=\"映射：map\"><a href=\"#映射：map\" class=\"headerlink\" title=\"映射：map\"></a>映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法。方法签名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; <span class=\"function\">Stream&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>该接口需要一个<code>Function</code>函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>\n<p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/limit%E8%AF%AD%E6%B3%95.jpg\"></p>\n<h4 id=\"复习Function接口\"><a href=\"#复习Function接口\" class=\"headerlink\" title=\"复习Function接口\"></a>复习Function接口</h4><p>此前我们已经学习过<code>java.util.stream.Function</code>函数式接口，其中唯一的抽象方法为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">R <span class=\"title\">apply</span><span class=\"params\">(T t)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。</p>\n<h4 id=\"基本使用-1\"><a href=\"#基本使用-1\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><p>Stream流中的<code>map</code>方法基本使用的代码如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo08StreamMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; original = Stream.of(<span class=\"string\">&quot;10&quot;</span>, <span class=\"string\">&quot;12&quot;</span>, <span class=\"string\">&quot;18&quot;</span>);</span><br><span class=\"line\">        Stream&lt;Integer&gt; result = original.map(str-&gt;Integer.parseInt(str));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码中，<code>map</code>方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为<code>Integer</code>类对象）。</p>\n<h3 id=\"统计个数：count\"><a href=\"#统计个数：count\" class=\"headerlink\" title=\"统计个数：count\"></a>统计个数：count</h3><p>正如旧集合<code>Collection</code>当中的<code>size</code>方法一样，流提供<code>count</code>方法来数一数其中的元素个数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo09StreamCount</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; original = Stream.of(<span class=\"string\">&quot;张无忌&quot;</span>, <span class=\"string\">&quot;张三丰&quot;</span>, <span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(<span class=\"string\">&quot;张&quot;</span>));</span><br><span class=\"line\">        System.out.println(result.count()); <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"取用前几个：limit\"><a href=\"#取用前几个：limit\" class=\"headerlink\" title=\"取用前几个：limit\"></a>取用前几个：limit</h3><p><code>limit</code>方法可以对流进行截取，只取用前n个。方法签名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Stream&lt;T&gt; <span class=\"title\">limit</span><span class=\"params\">(<span class=\"keyword\">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p>\n<p><img src=\"E:%5Cweb%25E5%25BC%2580%25E5%258F%2591%5C%25E8%25B5%2584%25E6%2596%2599%5Cday24-Stream%25E6%25B5%2581%25E3%2580%2581%25E6%2596%25B9%25E6%25B3%2595%25E5%25BC%2595%25E7%2594%25A8%5C%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD-day13-Stream%25E6%25B5%2581%25E3%2580%2581%25E6%2596%25B9%25E6%25B3%2595%25E5%25BC%2595%25E7%2594%25A8%5Cimg%5Climit%25E8%25AF%25AD%25E6%25B3%2595.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo10StreamLimit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; original = Stream.of(<span class=\"string\">&quot;张无忌&quot;</span>, <span class=\"string\">&quot;张三丰&quot;</span>, <span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; result = original.limit(<span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(result.count()); <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"跳过前几个：skip\"><a href=\"#跳过前几个：skip\" class=\"headerlink\" title=\"跳过前几个：skip\"></a>跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用<code>skip</code>方法获取一个截取之后的新流：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Stream&lt;T&gt; <span class=\"title\">skip</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>\n<p><img src=\"https://leehbucket1.oss-cn-beijing.aliyuncs.com/img/skip%E8%AF%AD%E6%B3%95.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo11StreamSkip</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; original = Stream.of(<span class=\"string\">&quot;张无忌&quot;</span>, <span class=\"string\">&quot;张三丰&quot;</span>, <span class=\"string\">&quot;周芷若&quot;</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; result = original.skip(<span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(result.count()); <span class=\"comment\">// 1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"组合：concat\"><a href=\"#组合：concat\" class=\"headerlink\" title=\"组合：concat\"></a>组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用<code>Stream</code>接口的静态方法<code>concat</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Stream&lt;T&gt; <span class=\"title\">concat</span><span class=\"params\">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>备注：这是一个静态方法，与<code>java.lang.String</code>当中的<code>concat</code>方法是不同的。</p>\n</blockquote>\n<p>该方法的基本使用代码如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo12StreamConcat</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; streamA = Stream.of(<span class=\"string\">&quot;张无忌&quot;</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; streamB = Stream.of(<span class=\"string\">&quot;张翠山&quot;</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-5-练习：集合元素处理（传统方式）\"><a href=\"#1-5-练习：集合元素处理（传统方式）\" class=\"headerlink\" title=\"1.5 练习：集合元素处理（传统方式）\"></a>1.5 练习：集合元素处理（传统方式）</h2><h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>现在有两个<code>ArrayList</code>集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）<strong>依次</strong>进行以下若干操作步骤：</p>\n<ol>\n<li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li>\n<li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li>\n<li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li>\n<li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li>\n<li>将两个队伍合并为一个队伍；存储到一个新集合中。</li>\n<li>根据姓名创建<code>Person</code>对象；存储到一个新集合中。</li>\n<li>打印整个队伍的Person对象信息。</li>\n</ol>\n<p>两个队伍（集合）的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoArrayListNames</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//第一支队伍</span></span><br><span class=\"line\">        ArrayList&lt;String&gt; one = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;迪丽热巴&quot;</span>);</span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;宋远桥&quot;</span>);</span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;苏星河&quot;</span>);</span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;石破天&quot;</span>);</span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;石中玉&quot;</span>);</span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;老子&quot;</span>);</span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;庄子&quot;</span>);</span><br><span class=\"line\">        one.add(<span class=\"string\">&quot;洪七公&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二支队伍</span></span><br><span class=\"line\">        ArrayList&lt;String&gt; two = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        two.add(<span class=\"string\">&quot;古力娜扎&quot;</span>);</span><br><span class=\"line\">        two.add(<span class=\"string\">&quot;张无忌&quot;</span>);</span><br><span class=\"line\">        two.add(<span class=\"string\">&quot;赵丽颖&quot;</span>);</span><br><span class=\"line\">        two.add(<span class=\"string\">&quot;张三丰&quot;</span>);</span><br><span class=\"line\">        two.add(<span class=\"string\">&quot;尼古拉斯赵四&quot;</span>);</span><br><span class=\"line\">        two.add(<span class=\"string\">&quot;张天爱&quot;</span>);</span><br><span class=\"line\">        two.add(<span class=\"string\">&quot;张二狗&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>Person</code>类的代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class=\"string\">&quot;&#x27;&#125;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><p>既然使用传统的for循环写法，那么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoArrayListNames</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; one = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; two = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class=\"line\">        List&lt;String&gt; oneA = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : one) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.length() == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                oneA.add(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class=\"line\">        List&lt;String&gt; oneB = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            oneB.add(oneA.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class=\"line\">        List&lt;String&gt; twoA = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : two) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.startsWith(<span class=\"string\">&quot;张&quot;</span>)) &#123;</span><br><span class=\"line\">                twoA.add(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class=\"line\">        List&lt;String&gt; twoB = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; twoA.size(); i++) &#123;</span><br><span class=\"line\">            twoB.add(twoA.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将两个队伍合并为一个队伍；</span></span><br><span class=\"line\">        List&lt;String&gt; totalNames = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        totalNames.addAll(oneB);</span><br><span class=\"line\">        totalNames.addAll(twoB);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据姓名创建Person对象；</span></span><br><span class=\"line\">        List&lt;Person&gt; totalPersonList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : totalNames) &#123;</span><br><span class=\"line\">            totalPersonList.add(<span class=\"keyword\">new</span> Person(name));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印整个队伍的Person对象信息。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Person person : totalPersonList) &#123;</span><br><span class=\"line\">            System.out.println(person);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&#123;name&#x3D;&#39;宋远桥&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;苏星河&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;石破天&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;张天爱&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;张二狗&#39;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-练习：集合元素处理（Stream方式）\"><a href=\"#1-6-练习：集合元素处理（Stream方式）\" class=\"headerlink\" title=\"1.6 练习：集合元素处理（Stream方式）\"></a>1.6 练习：集合元素处理（Stream方式）</h2><h3 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变，<code>Person</code>类的定义也不变。</p>\n<h3 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h3><p>等效的Stream流式处理代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoStreamNames</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; one = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; two = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class=\"line\">        <span class=\"comment\">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class=\"line\">        Stream&lt;String&gt; streamOne = one.stream().filter(s -&gt; s.length() == <span class=\"number\">3</span>).limit(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class=\"line\">        <span class=\"comment\">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class=\"line\">        Stream&lt;String&gt; streamTwo = two.stream().filter(s -&gt; s.startsWith(<span class=\"string\">&quot;张&quot;</span>)).skip(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将两个队伍合并为一个队伍；</span></span><br><span class=\"line\">        <span class=\"comment\">// 根据姓名创建Person对象；</span></span><br><span class=\"line\">        <span class=\"comment\">// 打印整个队伍的Person对象信息。</span></span><br><span class=\"line\">        Stream.concat(streamOne, streamTwo).map(Person::<span class=\"keyword\">new</span>).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行效果完全一样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&#123;name&#x3D;&#39;宋远桥&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;苏星河&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;石破天&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;张天爱&#39;&#125;</span><br><span class=\"line\">Person&#123;name&#x3D;&#39;张二狗&#39;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第二章-方法引用\"><a href=\"#第二章-方法引用\" class=\"headerlink\" title=\"第二章 方法引用\"></a>第二章 方法引用</h1><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p>\n<h2 id=\"2-1-冗余的Lambda场景\"><a href=\"#2-1-冗余的Lambda场景\" class=\"headerlink\" title=\"2.1 冗余的Lambda场景\"></a>2.1 冗余的Lambda场景</h2><p>来看一个简单的函数式接口以应用Lambda表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Printable</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Printable</code>接口当中唯一的抽象方法<code>print</code>接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo01PrintSimple</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printString</span><span class=\"params\">(Printable data)</span> </span>&#123;</span><br><span class=\"line\">      \tdata.print(<span class=\"string\">&quot;Hello, World!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tprintString(s -&gt; System.out.println(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>printString</code>方法只管调用<code>Printable</code>接口的<code>print</code>方法，而并不管<code>print</code>方法的具体实现逻辑会将字符串打印到什么地方去。而<code>main</code>方法通过Lambda表达式指定了函数式接口<code>Printable</code>的具体操作方案为：<strong>拿到String（类型可推导，所以可省略）数据后，在控制台中输出它</strong>。</p>\n<h2 id=\"2-2-问题分析\"><a href=\"#2-2-问题分析\" class=\"headerlink\" title=\"2.2 问题分析\"></a>2.2 问题分析</h2><p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是<code>System.out</code>对象中的<code>println(String)</code>方法。既然Lambda希望做的事情就是调用<code>println(String)</code>方法，那何必自己手动调用呢？</p>\n<h2 id=\"2-3-用方法引用改进代码\"><a href=\"#2-3-用方法引用改进代码\" class=\"headerlink\" title=\"2.3 用方法引用改进代码\"></a>2.3 用方法引用改进代码</h2><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo02PrintRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printString</span><span class=\"params\">(Printable data)</span> </span>&#123;</span><br><span class=\"line\">        data.print(<span class=\"string\">&quot;Hello, World!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tprintString(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意其中的双冒号<code>::</code>写法，这被称为“<strong>方法引用</strong>”，而双冒号是一种新的语法。</p>\n<h2 id=\"2-4-方法引用符\"><a href=\"#2-4-方法引用符\" class=\"headerlink\" title=\"2.4 方法引用符\"></a>2.4 方法引用符</h2><p>双冒号<code>::</code>为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p>\n<h3 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h3><p>例如上例中，<code>System.out</code>对象中有一个重载的<code>println(String)</code>方法恰好就是我们所需要的。那么对于<code>printString</code>方法的函数式接口参数，对比下面两种写法，完全等效：</p>\n<ul>\n<li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code></li>\n<li>方法引用写法：<code>System.out::println</code></li>\n</ul>\n<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给<code>System.out.println</code>方法去处理。</p>\n<p>第二种等效写法的语义是指：直接让<code>System.out</code>中的<code>println</code>方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>\n<p>注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>\n<h3 id=\"推导与省略\"><a href=\"#推导与省略\" class=\"headerlink\" title=\"推导与省略\"></a>推导与省略</h3><p>如果使用Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</p>\n<p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。</p>\n<p>下面这段代码将会调用<code>println</code>方法的不同重载形式，将函数式接口改为int类型的参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PrintableInteger</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> str)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo03PrintOverload</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printInteger</span><span class=\"params\">(PrintableInteger data)</span> </span>&#123;</span><br><span class=\"line\">      \tdata.print(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tprintInteger(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次方法引用将会自动匹配到<code>println(int)</code>的重载形式。</p>\n<h2 id=\"2-5-通过对象名引用成员方法\"><a href=\"#2-5-通过对象名引用成员方法\" class=\"headerlink\" title=\"2.5 通过对象名引用成员方法\"></a>2.5 通过对象名引用成员方法</h2><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodRefObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printUpperCase</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(str.toUpperCase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数式接口仍然定义为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Printable</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么当需要使用这个<code>printUpperCase</code>成员方法来替代<code>Printable</code>接口的Lambda的时候，已经具有了<code>MethodRefObject</code>类的对象实例，则可以通过对象名引用成员方法，代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo04MethodRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printString</span><span class=\"params\">(Printable lambda)</span> </span>&#123;</span><br><span class=\"line\">      \tlambda.print(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MethodRefObject obj = <span class=\"keyword\">new</span> MethodRefObject();</span><br><span class=\"line\">        printString(obj::printUpperCase);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-6-通过类名称引用静态方法\"><a href=\"#2-6-通过类名称引用静态方法\" class=\"headerlink\" title=\"2.6 通过类名称引用静态方法\"></a>2.6 通过类名称引用静态方法</h2><p>由于在<code>java.lang.Math</code>类中已经存在了静态方法<code>abs</code>，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Calcable</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一种写法是使用Lambda表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo05Lambda</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> num, Calcable lambda)</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(lambda.calc(num));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tmethod(-<span class=\"number\">10</span>, n -&gt; Math.abs(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是使用方法引用的更好写法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo06MethodRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> num, Calcable lambda)</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(lambda.calc(num));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tmethod(-<span class=\"number\">10</span>, Math::abs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，下面两种写法是等效的：</p>\n<ul>\n<li>Lambda表达式：<code>n -&gt; Math.abs(n)</code></li>\n<li>方法引用：<code>Math::abs</code></li>\n</ul>\n<h2 id=\"2-7-通过super引用成员方法\"><a href=\"#2-7-通过super引用成员方法\" class=\"headerlink\" title=\"2.7 通过super引用成员方法\"></a>2.7 通过super引用成员方法</h2><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Greetable</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">greet</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是父类<code>Human</code>的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(<span class=\"string\">&quot;Hello!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是子类<code>Man</code>的内容，其中使用了Lambda的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;大家好,我是Man!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义方法method,参数传递Greetable接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Greetable g)</span></span>&#123;</span><br><span class=\"line\">        g.greet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用method方法,使用Lambda表达式</span></span><br><span class=\"line\">        method(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建Human对象,调用sayHello方法</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> Human().sayHello();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//简化Lambda</span></span><br><span class=\"line\">        method(()-&gt;<span class=\"keyword\">new</span> Human().sayHello());</span><br><span class=\"line\">        <span class=\"comment\">//使用super关键字代替父类对象</span></span><br><span class=\"line\">        method(()-&gt;<span class=\"keyword\">super</span>.sayHello());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是如果使用方法引用来调用父类中的<code>sayHello</code>方法会更好，例如另一个子类<code>Woman</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;大家好,我是Man!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义方法method,参数传递Greetable接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Greetable g)</span></span>&#123;</span><br><span class=\"line\">        g.greet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        method(<span class=\"keyword\">super</span>::sayHello);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，下面两种写法是等效的：</p>\n<ul>\n<li>Lambda表达式：<code>() -&gt; super.sayHello()</code></li>\n<li>方法引用：<code>super::sayHello</code></li>\n</ul>\n<h2 id=\"2-8-通过this引用成员方法\"><a href=\"#2-8-通过this引用成员方法\" class=\"headerlink\" title=\"2.8 通过this引用成员方法\"></a>2.8 通过this引用成员方法</h2><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“<strong>this::成员方法</strong>”的格式来使用方法引用。首先是简单的函数式接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Richable</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buy</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个丈夫<code>Husband</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Richable lambda)</span> </span>&#123;</span><br><span class=\"line\">      \tlambda.buy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beHappy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \tmarry(() -&gt; System.out.println(<span class=\"string\">&quot;买套房子&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开心方法<code>beHappy</code>调用了结婚方法<code>marry</code>，后者的参数为函数式接口<code>Richable</code>，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对<code>Husband</code>丈夫类进行修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">buyHouse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(<span class=\"string\">&quot;买套房子&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Richable lambda)</span> </span>&#123;</span><br><span class=\"line\">      \tlambda.buy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beHappy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \tmarry(() -&gt; <span class=\"keyword\">this</span>.buyHouse());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">buyHouse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(<span class=\"string\">&quot;买套房子&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">marry</span><span class=\"params\">(Richable lambda)</span> </span>&#123;</span><br><span class=\"line\">      \tlambda.buy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beHappy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      \tmarry(<span class=\"keyword\">this</span>::buyHouse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，下面两种写法是等效的：</p>\n<ul>\n<li>Lambda表达式：<code>() -&gt; this.buyHouse()</code></li>\n<li>方法引用：<code>this::buyHouse</code></li>\n</ul>\n<h2 id=\"2-9-类的构造器引用\"><a href=\"#2-9-类的构造器引用\" class=\"headerlink\" title=\"2.9 类的构造器引用\"></a>2.9 类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用<code>类名称::new</code>的格式表示。首先是一个简单的<code>Person</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是用来创建<code>Person</code>对象的函数式接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">buildPerson</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使用这个函数式接口，可以通过Lambda表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo09Lambda</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">(String name, PersonBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(builder.buildPerson(name).getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tprintName(<span class=\"string\">&quot;赵丽颖&quot;</span>, name -&gt; <span class=\"keyword\">new</span> Person(name));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是通过构造器引用，有更好的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo10ConstructorRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">(String name, PersonBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(builder.buildPerson(name).getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \tprintName(<span class=\"string\">&quot;赵丽颖&quot;</span>, Person::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，下面两种写法是等效的：</p>\n<ul>\n<li>Lambda表达式：<code>name -&gt; new Person(name)</code></li>\n<li>方法引用：<code>Person::new</code></li>\n</ul>\n<h2 id=\"2-10-数组的构造器引用\"><a href=\"#2-10-数组的构造器引用\" class=\"headerlink\" title=\"2.10 数组的构造器引用\"></a>2.10 数组的构造器引用</h2><p>数组也是<code>Object</code>的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，需要一个函数式接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ArrayBuilder</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">int</span>[] buildArray(<span class=\"keyword\">int</span> length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在应用该接口的时候，可以通过Lambda表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo11ArrayInitRef</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] initArray(<span class=\"keyword\">int</span> length, ArrayBuilder builder) &#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> builder.buildArray(length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">int</span>[] array = initArray(<span class=\"number\">10</span>, length -&gt; <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是更好的写法是使用数组的构造器引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo12ArrayInitRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] initArray(<span class=\"keyword\">int</span> length, ArrayBuilder builder) &#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> builder.buildArray(length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">int</span>[] array = initArray(<span class=\"number\">10</span>, <span class=\"keyword\">int</span>[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，下面两种写法是等效的：</p>\n<ul>\n<li>Lambda表达式：<code>length -&gt; new int[length]</code></li>\n<li>方法引用：<code>int[]::new</code></li>\n</ul>\n","categories":[{"name":"Java学习","slug":"Java学习","count":1,"path":"api/categories/Java学习.json"}],"tags":[{"name":"Stream流","slug":"Stream流","count":1,"path":"api/tags/Stream流.json"}]}